'use strict'

exports.__esModule = true
exports.default = exports.canHover = void 0

var _react = require('react')

const canHover =
  typeof window !== 'undefined'
    ? !window.matchMedia('(hover: none)').matches
    : false
exports.canHover = canHover
const emptyArr = []

var _default = (enterDelay, leaveDelay) => {
  const [isHovering, setHovering] = (0, _react.useState)(false)
  const timeout = (0, _react.useRef)(null)
  const element = (0, _react.useRef)(null) // here for compatibility reasons with certain libs

  const setElementRef = (0, _react.useCallback)(
    el => (element.current = el),
    emptyArr
  )
  const toggle = (0, _react.useCallback)((value, delay) => {
    if (canHover === false) {
      return
    }

    if (timeout.current !== null) {
      clearTimeout(timeout.current)
      timeout.current = null
    }

    if (delay) {
      timeout.current = setTimeout(() => setHovering(value), delay)
    } else {
      setHovering(value)
    }
  }, emptyArr)
  const onEnter = (0, _react.useCallback)(() => toggle(true, enterDelay), [
    enterDelay,
    toggle,
  ])
  const onLeave = (0, _react.useCallback)(() => toggle(false, leaveDelay), [
    leaveDelay,
    toggle,
  ])
  ;(0, _react.useEffect)(() => {
    if (element.current !== null) {
      element.current.addEventListener('mouseenter', onEnter)
      element.current.addEventListener('mouseleave', onLeave)
    }

    return () => {
      if (element.current !== null) {
        element.current.removeEventListener('mouseenter', onEnter)
        element.current.removeEventListener('mouseleave', onLeave)
      }
    }
  }, [element.current, onEnter, onLeave]) // cleans up timeout on unmount

  ;(0, _react.useEffect)(
    () => () => timeout.current !== null && clearTimeout(timeout.current),
    emptyArr
  )
  return [setElementRef, isHovering]
}

exports.default = _default
